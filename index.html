<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>×¤×¡×˜×™×‘×œ ×”× ×“×™×‘ 7 ××¤×”</title>
  <!-- Leaflet CSS -->
  <link
    rel="stylesheet"
    href="https://unpkg.com/leaflet/dist/leaflet.css"
  />
  <style>
    /* Reset margin and padding */
    body,
    html {
      margin: 0;
      padding: 0;
      height: 100%;
    }

    /* Fullâ€‘page map container */
    #map {
      height: 100vh;
      width: 100%;
    }

    /* Popup styling */
    .popup {
      max-width: 300px;
      line-height: 1.4;
    }
    .popup h3 {
      margin-top: 0;
    }

    /* Details sidebar for event information */
    #details {
      position: absolute;
      top: 10px;
      right: 10px;
      width: 320px;
      max-height: 90vh;
      overflow-y: auto;
      background: rgba(255, 255, 255, 0.95);
      border-radius: 8px;
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
      padding: 12px;
      font-size: 14px;
    }
    #details h3 {
      margin-top: 0;
    }

    /* Sidebar for statistics and event list */
    #sidebar {
      position: absolute;
      top: 10px;
      left: 10px;
      width: 320px;
      max-height: 90vh;
      overflow-y: auto;
      background: rgba(255, 255, 255, 0.95);
      border-radius: 8px;
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
      padding: 12px;
      font-size: 14px;
      z-index: 1000;
    }
    #counts {
      margin-bottom: 8px;
    }
    /* Container for the date filter input */
    #dateFilterContainer {
      margin-bottom: 8px;
    }
    #eventList {
      /* Reserve space for filter checkboxes and counts */
      max-height: calc(90vh - 200px);
      overflow-y: auto;
    }
    #dayFilterContainer,
    #availableFilterContainer {
      margin-bottom: 8px;
    }
    .event-item {
      cursor: pointer;
      padding: 4px 0;
      border-bottom: 1px solid #eee;
      /* Align Hebrew text to the right within each event item */
      direction: rtl;
      text-align: right;
    }
    .event-item:hover {
      background-color: #f5f5f5;
    }
    .event-item.active {
      background-color: #d0eaff;
    }
    /* Style for events that could not be geocoded */
    .event-item.not-found {
      color: #999;
      font-style: italic;
    }

    /* Progress bar styling */
    #geocodeProgress {
      display: none;
      margin-bottom: 12px;
      padding: 8px;
      background: #f0f8ff;
      border-radius: 4px;
      border: 1px solid #ccc;
    }

    #geocodeProgress.active {
      display: block;
    }

    #geocodeProgress p {
      margin: 0 0 6px 0;
      font-size: 13px;
      font-weight: bold;
    }

    .progress-bar-container {
      width: 100%;
      height: 20px;
      background: #e0e0e0;
      border-radius: 4px;
      overflow: hidden;
      position: relative;
    }

    .progress-bar-fill {
      height: 100%;
      background: linear-gradient(90deg, #4CAF50, #45a049);
      width: 0%;
      transition: width 0.3s ease;
      display: flex;
      align-items: center;
      justify-content: center;
      color: white;
      font-size: 11px;
      font-weight: bold;
    }

    /* Search input styling */
    #searchInput {
      width: 100%;
      padding: 8px;
      margin-bottom: 8px;
      border: 1px solid #ccc;
      border-radius: 4px;
      font-size: 14px;
      direction: rtl;
      text-align: right;
    }

    #searchInput::placeholder {
      color: #999;
    }

    /* Favorite/bookmark button styling */
    .btn-favorite {
      background: none;
      border: none;
      font-size: 20px;
      cursor: pointer;
      padding: 4px 8px;
      transition: transform 0.2s;
    }

    .btn-favorite:hover {
      transform: scale(1.2);
    }

    .btn-favorite.favorited {
      filter: drop-shadow(0 0 3px #ff6b6b);
    }

    /* Directions button */
    .btn-directions {
      background: #4CAF50;
      color: white;
      border: none;
      padding: 8px 12px;
      border-radius: 4px;
      cursor: pointer;
      margin-top: 8px;
      font-size: 14px;
      width: 100%;
      transition: background 0.2s;
    }

    .btn-directions:hover {
      background: #45a049;
    }

    /* "Next nearby events" section */
    .next-events-section {
      margin-top: 12px;
      padding: 8px;
      background: #fffacd;
      border-radius: 4px;
      border-left: 3px solid #FFD700;
    }

    .next-events-section h4 {
      margin: 0 0 8px 0;
      font-size: 13px;
      color: #333;
    }

    .next-event-item {
      background: white;
      padding: 6px;
      margin-bottom: 6px;
      border-radius: 3px;
      border: 1px solid #ddd;
      font-size: 12px;
      cursor: pointer;
      transition: background 0.2s;
    }

    .next-event-item:hover {
      background: #f0f0f0;
    }

    .next-event-time {
      color: #FF6347;
      font-weight: bold;
      font-size: 11px;
    }

    .next-event-distance {
      color: #666;
      font-size: 11px;
    }

    /* Event highlighting by time */
    .event-item.happening-now {
      background: #90EE90;
      border-left: 3px solid #228B22;
    }

    .event-item.happening-soon {
      background: #FFFFE0;
      border-left: 3px solid #FFD700;
    }

    /* Align Hebrew text to the right for RTL languages */
    #sidebar,
    #details,
    .popup {
      direction: rtl;
      text-align: right;
    }
  </style>
</head>
<body>
  <div id="map"></div>

  <!-- Details panel shown on marker click -->
  <div id="details">
    <p>Select an event marker to view details here.</p>
  </div>

  <!-- Sidebar containing event statistics and list -->
  <div id="sidebar">
    <!-- Progress bar for background geocoding -->
    <div id="geocodeProgress">
      <p>ğŸ” ××—×¤×© ×§×•××•×¨×“×™× ×˜×•×ª...</p>
      <div class="progress-bar-container">
        <div class="progress-bar-fill" id="progressBarFill"></div>
      </div>
      <p id="progressText" style="text-align: center; margin: 4px 0 0 0; font-size: 12px;"></p>
    </div>
    <!-- Search input for event name -->
    <input
      type="text"
      id="searchInput"
      placeholder="×—×¤×© ××™×¨×•×¢ ×œ×¤×™ ×©×..."
      style="margin-bottom: 8px;"
    />
    <!-- Day filter checkboxes will be inserted here dynamically -->
    <div id="dayFilterContainer">
      <strong>×¡×™× ×•×Ÿ ×œ×¤×™ ×™××™×:</strong><br />
    </div>
    <!-- Available events checkbox -->
    <div id="availableFilterContainer">
      <label><input type="checkbox" id="availableFilter" /> ×¨×§ ××™×¨×•×¢×™× ×¢× ××§×•××•×ª ×¤× ×•×™×™×</label>
    </div>
    <div id="counts">
      ×˜×•×¢×Ÿ ××™×¨×•×¢×™×...
    </div>
    <div id="eventList"></div>
  </div>

  <!-- Leaflet JS -->
  <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
  <script>
    /*
      This script initializes a map centered on Pardes Hanaâ€“Karkur and
      automatically fetches festival events for 2025 from the Hanadiv API. For
      each event it performs a geocode lookup via photon.komoot.io to get
      approximate latitude/longitude based on the street and house number, then
      adds a marker with a popup containing the event details and external
      links. Note: geocoding may occasionally fail for ambiguous or incomplete
      addresses; those events will simply be skipped.
    */

    // Cache for geocode results. We use localStorage to persist across sessions.
    const geocodeCache = (() => {
      try {
        const stored = localStorage.getItem('geocodeCache');
        return stored ? JSON.parse(stored) : {};
      } catch (e) {
        return {};
      }
    })();

    // Initialize the map centered on Pardes Hanaâ€“Karkur
    const map = L.map('map').setView([32.475, 34.975], 13);

    // Store markers by event ID for easy lookup when selecting from the list
    const markers = {};

    // Map of location key to marker for handling multiple events at the same location
    const markerLocationMap = {};
    // Map of event ID to corresponding list item element for highlighting
    const listItemByEventId = {};

    // Favorites storage (using localStorage for persistence)
    const favorites = (() => {
      try {
        const stored = localStorage.getItem('eventFavorites');
        return stored ? JSON.parse(stored) : new Set();
      } catch (e) {
        return new Set();
      }
    })();

    // Coordinate overrides - manual corrections for events
    // Format: { eventID: { lat, lng }, ... }
    const coordinateOverrides = (() => {
      try {
        const stored = localStorage.getItem('coordinateOverrides');
        return stored ? JSON.parse(stored) : {};
      } catch (e) {
        console.warn('Could not load coordinate overrides from localStorage:', e);
        return {};
      }
    })();

    // Error tracking for visual indicators
    const eventErrors = new Set();

    // Current search query
    let currentSearchQuery = '';

    // Add OpenStreetMap tiles
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors',
      maxZoom: 19,
    }).addTo(map);

    // Helper to create safe HTML links from optional fields
    function createLink(url) {
      if (!url) return '';
      // If the URL does not start with a protocol, prepend https://
      const hasProtocol = /^(https?:)?\/\//.test(url);
      const fullUrl = hasProtocol ? url : 'https://' + url;
      return '<a href="' + fullUrl + '" target="_blank" rel="noopener">' + url + '</a>';
    }

    // Error logging helper
    function logError(context, error) {
      const timestamp = new Date().toISOString();
      const errorMsg = error instanceof Error ? error.message : String(error);
      console.error(`[${timestamp}] ${context}:`, errorMsg, error);
    }

    // Load corrections and geocode cache from GitHub repository (non-blocking)
    async function loadCorrectionsFromGitHub() {
      try {
        // Use a timeout to prevent hanging if GitHub is slow or unreachable
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), 5000); // 5 second timeout

        const response = await fetch(
          'https://raw.githubusercontent.com/dvirarad/hnadiv-festival-7/main/web-app/corrections.json',
          { signal: controller.signal }
        );
        clearTimeout(timeoutId);

        if (!response.ok) {
          throw new Error(`HTTP ${response.status}: Failed to fetch corrections`);
        }
        const data = await response.json();

        // Merge GitHub corrections into coordinateOverrides
        if (data.overrides && typeof data.overrides === 'object') {
          Object.assign(coordinateOverrides, data.overrides);
          console.log(`Loaded ${Object.keys(data.overrides).length} corrections from GitHub`);
        }

        // Merge GitHub geocode cache
        if (data.geocodeCache && typeof data.geocodeCache === 'object') {
          Object.assign(geocodeCache, data.geocodeCache);
          console.log(`Loaded ${Object.keys(data.geocodeCache).length} cached geocoding results from GitHub`);
        }

        return true;
      } catch (err) {
        logError('loadCorrectionsFromGitHub', err);
        console.warn('Failed to load corrections from GitHub, using local cache only');
        return false;
      }
    }

    // Save correction to GitHub (admin function - will be expanded in Phase 2)
    async function saveCorrectionsToGitHub(eventID, lat, lng, reason = '') {
      try {
        // For now, this function validates the data structure
        // Full GitHub API integration with authentication will be in Phase 2
        if (!eventID || typeof lat !== 'number' || typeof lng !== 'number') {
          throw new Error('Invalid correction data');
        }

        console.log(`Correction queued for GitHub sync: Event ${eventID} -> ${lat}, ${lng}`);

        // TODO: In Phase 2, implement actual GitHub API commit
        // This will require:
        // 1. GitHub Personal Access Token (from environment variable)
        // 2. Fetch current corrections.json
        // 3. Update with new override
        // 4. Create commit via GitHub API

        return true;
      } catch (err) {
        logError(`saveCorrectionsToGitHub(${eventID})`, err);
        return false;
      }
    }

    // Sync geocode cache to localStorage (called periodically and on page unload)
    function syncCacheToLocalStorage() {
      try {
        // Save current geocodeCache to localStorage
        localStorage.setItem('geocodeCache', JSON.stringify(geocodeCache));
        console.log('âœ… Geocode cache synced to localStorage', Object.keys(geocodeCache).length + ' entries');
        return true;
      } catch (err) {
        console.warn('âš ï¸ Could not sync geocode cache to localStorage:', err);
        return false;
      }
    }

    // Export cache as corrections.json format (for manual GitHub sync)
    function exportCacheAsJSON() {
      try {
        const correctionData = {
          overrides: coordinateOverrides,
          geocodeCache: geocodeCache,
          lastUpdated: new Date().toISOString(),
          version: '1.0',
          description: 'Festival location corrections, geocoding cache, and coordinate overrides'
        };

        const json = JSON.stringify(correctionData, null, 2);
        console.log('ğŸ“‹ Corrections data ready for export:');
        console.log(json);

        // Trigger browser download
        const blob = new Blob([json], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const link = document.createElement('a');
        link.href = url;
        link.download = 'corrections.json';
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(url);

        console.log('âœ… Corrections.json exported! File downloaded.');
        alert('âœ… corrections.json exported! You can now manually commit and push to GitHub.');
        return true;
      } catch (err) {
        logError('exportCacheAsJSON', err);
        alert('âŒ Failed to export corrections.json');
        return false;
      }
    }

    // Sync cache to GitHub corrections.json (Phase 2 - currently logs intent)
    async function syncCacheToGitHub() {
      try {
        console.log('ğŸ“¤ Preparing to sync geocode cache to GitHub...');
        console.log('Cache entries to sync:', Object.keys(geocodeCache).length);

        // Log all cache entries for debugging
        Object.entries(geocodeCache).forEach(([query, data]) => {
          console.log(`  - "${query}" -> ${data.lat}, ${data.lng}`);
        });

        // For manual sync: call exportCacheAsJSON() to download the file
        console.log('â„¹ï¸  For manual sync: Use exportCacheAsJSON() to download corrections.json');
        console.log('âœ“ Geocode cache ready for manual GitHub sync (Phase 2)');
        return true;
      } catch (err) {
        logError('syncCacheToGitHub', err);
        return false;
      }
    }

    // Save geocoding result to cache (both locally and queued for GitHub)
    function cacheGeocodingResult(query, lat, lng) {
      try {
        if (!query || typeof lat !== 'number' || typeof lng !== 'number') {
          return false;
        }

        // Store in geocodeCache object
        geocodeCache[query] = {
          lat,
          lng,
          timestamp: new Date().toISOString()
        };

        // Save to localStorage for persistence between sessions
        try {
          localStorage.setItem('geocodeCache', JSON.stringify(geocodeCache));
        } catch (e) {
          console.warn('Could not save geocode cache to localStorage:', e);
        }

        console.log(`Cached geocoding result for "${query}": ${lat}, ${lng}`);

        // Queue for GitHub sync (Phase 2 will implement actual sync)
        // For now just log that it needs to be synced
        console.log(`Geocoding cache queued for GitHub sync`);

        return true;
      } catch (err) {
        logError(`cacheGeocodingResult("${query}")`, err);
        return false;
      }
    }

    // Get coordinates for an event - checks overrides first, then cache
    function getEventCoordinates(event) {
      // Check for manual override first (highest priority)
      if (coordinateOverrides[event.eventID]) {
        return coordinateOverrides[event.eventID];
      }
      // Fall back to auto-geocoded coordinates
      if (markers[event.eventID] && markers[event.eventID].lat) {
        return { lat: markers[event.eventID].lat, lng: markers[event.eventID].lng };
      }
      return null;
    }

    // Save coordinate override for an event
    function saveCoordinateOverride(eventID, lat, lng, reason = 'Manual correction') {
      try {
        coordinateOverrides[eventID] = { lat, lng };
        localStorage.setItem('coordinateOverrides', JSON.stringify(coordinateOverrides));
        console.log(`Saved coordinate override for event ${eventID}: ${lat}, ${lng}`);

        // Also attempt to save to GitHub (non-blocking)
        // This will be fully implemented in Phase 2 with proper authentication
        saveCorrectionsToGitHub(eventID, lat, lng, reason).catch(err => {
          console.warn('GitHub save queued for later sync:', eventID);
        });

        return true;
      } catch (e) {
        logError(`saveCoordinateOverride(${eventID})`, e);
        return false;
      }
    }

    // Toggle favorite status for an event
    function toggleFavorite(eventID) {
      if (favorites.has(eventID)) {
        favorites.delete(eventID);
      } else {
        favorites.add(eventID);
      }
      // Save to localStorage
      try {
        localStorage.setItem('eventFavorites', JSON.stringify(Array.from(favorites)));
      } catch (e) {
        console.warn('Could not save favorites to localStorage');
      }

      // Update the favorite button in details panel instead of re-rendering entire list
      const favBtn = document.querySelector('.btn-favorite');
      if (favBtn) {
        const favIcon = isFavorited(eventID) ? 'â¤ï¸' : 'ğŸ¤';
        favBtn.textContent = favIcon + ' ××”×‘×ª×™';
        favBtn.classList.toggle('favorited');
      }

      // Update the favorite indicators in the event list (more efficient)
      const listItems = document.querySelectorAll('.event-item');
      listItems.forEach(item => {
        const itemBtn = item.querySelector('.favorite-indicator');
        if (itemBtn) {
          const eid = item.dataset.eventId;
          if (isFavorited(eid)) {
            itemBtn.textContent = 'â¤ï¸';
          } else {
            itemBtn.textContent = 'ğŸ¤';
          }
        }
      });
    }

    // Check if event is favorited
    function isFavorited(eventID) {
      return favorites.has(eventID) || (Array.isArray(favorites) && favorites.includes(eventID));
    }

    // Calculate distance between two coordinates (in km)
    function calculateDistance(lat1, lng1, lat2, lng2) {
      const R = 6371; // Earth's radius in km
      const dLat = (lat2 - lat1) * Math.PI / 180;
      const dLng = (lng2 - lng1) * Math.PI / 180;
      const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
                Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                Math.sin(dLng / 2) * Math.sin(dLng / 2);
      const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
      return R * c;
    }

    // Parse time string (HH:MM format) to minutes since midnight
    function timeToMinutes(timeStr) {
      if (!timeStr) return null;
      const parts = timeStr.split(':');
      return parseInt(parts[0]) * 60 + parseInt(parts[1]);
    }

    // Check if event is happening now (within current hour)
    function isHappeningNow(event) {
      const now = new Date();
      const currentHour = ('0' + now.getHours()).slice(-2);
      const currentMinute = ('0' + now.getMinutes()).slice(-2);
      const currentTime = currentHour + ':' + currentMinute;
      const currentMinutes = timeToMinutes(currentTime);
      const eventStartMinutes = timeToMinutes(event.hour);
      const eventEndMinutes = eventStartMinutes + 120; // Assume 2 hour events
      return eventStartMinutes && currentMinutes >= eventStartMinutes && currentMinutes < eventEndMinutes;
    }

    // Check if event is happening soon (within next 30 minutes)
    function isHappeningSoon(event) {
      const now = new Date();
      const currentHour = ('0' + now.getHours()).slice(-2);
      const currentMinute = ('0' + now.getMinutes()).slice(-2);
      const currentTime = currentHour + ':' + currentMinute;
      const currentMinutes = timeToMinutes(currentTime);
      const eventStartMinutes = timeToMinutes(event.hour);
      return eventStartMinutes && currentMinutes < eventStartMinutes && eventStartMinutes - currentMinutes <= 30;
    }

    // Find nearby events that start around when current event ends
    function findNextNearbyEvents(event, maxDistanceKm = 0.5) {
      const nextEvents = [];
      if (!markers[event.eventID] || !markers[event.eventID].lat) return nextEvents;

      const eventCoords = markers[event.eventID];
      const eventEndMinutes = timeToMinutes(event.hour) + 120; // Assume 2 hour events

      window.allEvents.forEach(otherEvent => {
        if (otherEvent.eventID === event.eventID) return;
        if (!markers[otherEvent.eventID] || !markers[otherEvent.eventID].lat) return;

        const otherCoords = markers[otherEvent.eventID];
        const distance = calculateDistance(eventCoords.lat, eventCoords.lng, otherCoords.lat, otherCoords.lng);

        if (distance > maxDistanceKm) return;

        const otherStartMinutes = timeToMinutes(otherEvent.hour);
        // Check if other event starts within 30-90 minutes after current event ends
        if (otherStartMinutes && otherStartMinutes >= eventEndMinutes && otherStartMinutes <= eventEndMinutes + 60) {
          nextEvents.push({
            event: otherEvent,
            distance: distance,
            startMinutes: otherStartMinutes
          });
        }
      });

      // Sort by start time
      nextEvents.sort((a, b) => a.startMinutes - b.startMinutes);
      return nextEvents.slice(0, 3); // Return top 3
    }

    // Update the details panel with full event information
    function updateDetails(event, lat, lng) {
      try {
        const detailsEl = document.getElementById('details');
      // Compose optional links
      const link1 = createLink(event.externalLink1);
      const link2 = createLink(event.externalLink2);
      const links = [link1, link2].filter(Boolean).join(' | ');
      // Compose amenities information
      const amenities = [];
      if (event.hasParking) amenities.push('Parking');
      if (event.isAccessible) amenities.push('Accessible');
      if (event.petFriendly) amenities.push('Pet friendly');
      if (event.piano) amenities.push('Piano available');
      if (event.canHostNoisyEvents) amenities.push('Noisy events allowed');
      const amenitiesInfo = amenities.join(', ');
      // Build the full address/geocode query string for display
      const addrParts = [];
      if (event.street) addrParts.push(event.street);
      if (event.houseNumber) addrParts.push(event.houseNumber);
      addrParts.push('Pardes Hana-Karkur');
      addrParts.push('Israel');
      const geocodeQuery = addrParts.filter(Boolean).join(' ');
      // Compose content HTML
      let html = '';
      html += '<h3>' + (event.title || '') + '</h3>';
      // Date and hour
      html += '<p><strong>×ª××¨×™×š:</strong> ' + (event.date || '') + '</p>';
      if (event.hour) {
        html += '<p><strong>×©×¢×”:</strong> ' + event.hour + '</p>';
      }
      // Display the geocode query string used for lookup
      html += '<p><strong>×›×ª×•×‘×ª ×œ×—×™×¤×•×©:</strong> ' + geocodeQuery + '</p>';
      // Show individual address fields
      if (event.placeDescription) html += '<p><strong>×ª×™××•×¨ ×”××§×•×:</strong> ' + event.placeDescription + '</p>';
      if (event.street) html += '<p><strong>×¨×—×•×‘:</strong> ' + event.street + '</p>';
      if (event.houseNumber) html += '<p><strong>××¡×¤×¨ ×‘×™×ª:</strong> ' + event.houseNumber + '</p>';
      // Show capacity information: number of registrants vs the smallest specified capacity
      const attendeesCount = (event.attendees && Array.isArray(event.attendees)) ? event.attendees.length : 0;
      // Determine actual capacity using totalNumberOfPeopleThatCanAttend, limitNumberOfPeople or maxNumberOfPeople
      const caps = [];
      if (typeof event.totalNumberOfPeopleThatCanAttend === 'number') caps.push(event.totalNumberOfPeopleThatCanAttend);
      if (typeof event.limitNumberOfPeople === 'number') caps.push(event.limitNumberOfPeople);
      if (typeof event.maxNumberOfPeople === 'number') caps.push(event.maxNumberOfPeople);
      const positiveCaps = caps.filter(cap => cap > 0);
      if (positiveCaps.length > 0) {
        const actualCap = Math.min.apply(null, positiveCaps);
        html += '<p><strong>×ª×¤×•×¡×”:</strong> ' + attendeesCount + ' / ' + actualCap + '</p>';
      }
      // Event details
      if (event.details) html += '<p>' + event.details.replace(/\n/g, '<br>') + '</p>';
      // External links
      if (links) html += '<p>' + links + '</p>';
      // Link to the festival event page
      if (event.eventID) {
        const eventPageUrl = 'https://2025.hanadiv.org/event-page/' + event.eventID;
        html += '<p><a href="' + eventPageUrl + '" target="_blank" rel="noopener">×œ×¢××•×“ ×”××™×¨×•×¢</a></p>';
      }
      // Coordinates
      if (typeof lat === 'number' && typeof lng === 'number') {
        html += '<p><strong>×§×•××•×¨×“×™× ×˜×•×ª:</strong> ' + lat.toFixed(5) + ', ' + lng.toFixed(5) + '</p>';
      } else {
        html += '<p><strong>×§×•××•×¨×“×™× ×˜×•×ª:</strong> ×œ× ×–××™× ×•×ª (×œ× × ×™×ª×Ÿ ×œ××ª×¨ ××ª ×”××™×§×•×)</p>';
      }

      // Add favorite button
      const favIcon = isFavorited(event.eventID) ? 'â¤ï¸' : 'ğŸ¤';
      html += '<button class="btn-favorite ' + (isFavorited(event.eventID) ? 'favorited' : '') + '" onclick="event.stopPropagation(); toggleFavorite(' + event.eventID + '); return false;">' + favIcon + ' ××”×‘×ª×™</button>';

      // Add directions button if we have coordinates
      if (typeof lat === 'number' && typeof lng === 'number') {
        html += '<button class="btn-directions" onclick="event.stopPropagation(); openMaps(' + lat + ', ' + lng + ', \'' + (event.title || 'Event').replace(/'/g, "\\'") + '\'); return false;">ğŸ—ºï¸ ×”×•×¨××•×ª ×“×¨×š</button>';
      }

      // Add next nearby events section
      const nextEvents = findNextNearbyEvents(event);
      if (nextEvents.length > 0) {
        html += '<div class="next-events-section">';
        html += '<h4>ğŸ¯ ××™×¨×•×¢×™× ×§×¨×•×‘×™× ×‘×¡××•×š:</h4>';
        nextEvents.forEach(item => {
          const minutes = item.startMinutes % 60;
          const hours = Math.floor(item.startMinutes / 60);
          const timeStr = ('0' + hours).slice(-2) + ':' + ('0' + minutes).slice(-2);
          html += '<div class="next-event-item" onclick="highlightListItem(' + item.event.eventID + '); map.setView([' + item.event.lat + ', ' + item.event.lng + '], 15);">';
          html += '<div><strong>' + (item.event.title || 'Event') + '</strong></div>';
          html += '<div class="next-event-time">â° ' + timeStr + '</div>';
          html += '<div class="next-event-distance">ğŸ“ ' + item.distance.toFixed(2) + ' km</div>';
          html += '</div>';
        });
        html += '</div>';
      }

      detailsEl.innerHTML = html;
      } catch (err) {
        logError(`updateDetails(${event.eventID})`, err);
        const detailsEl = document.getElementById('details');
        if (detailsEl) {
          detailsEl.innerHTML = '<p style="color: red;">âŒ ×©×’×™××” ×‘×”×¦×’×ª ×¤×¨×˜×™ ×”××™×¨×•×¢</p>';
        }
      }
    }

    // Open maps with directions
    function openMaps(lat, lng, title) {
      try {
        if (typeof lat !== 'number' || typeof lng !== 'number') {
          throw new Error('Invalid coordinates');
        }
        // Check if user is on mobile
        const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
        if (isMobile) {
          // Try Apple Maps first on iOS, Google Maps on Android
          const isIOS = /iPhone|iPad|iPod/i.test(navigator.userAgent);
          if (isIOS) {
            window.open('maps://maps.apple.com/?daddr=' + lat + ',' + lng + '&q=' + encodeURIComponent(title));
          } else {
            window.open('https://www.google.com/maps/search/?api=1&query=' + lat + ',' + lng);
          }
        } else {
          // Desktop - open Google Maps
          window.open('https://www.google.com/maps/search/?api=1&query=' + lat + ',' + lng);
        }
      } catch (err) {
        logError(`openMaps(${lat}, ${lng})`, err);
        alert('×œ× × ×™×ª×Ÿ ×œ×¤×ª×•×— ××¤×”. ×‘×“×•×§ ××ª ×”×§×•××•×¨×“×™× ×˜×•×ª.');
      }
    }

    // Shared geocoding helper function used by both initial load and background geocoding
    // This function tries multiple geocoding services and strategies for reliable results
    async function tryGeocode(query) {
      // If we already have this query cached, return it immediately (from GitHub or localStorage)
      if (geocodeCache[query]) {
        console.log(`Using cached geocoding result for "${query}"`);
        return geocodeCache[query];
      }
      try {
        // First try Photon API (faster, good for most queries)
        const photonUrl = 'https://photon.komoot.io/api/?q=' + encodeURIComponent(query) + '&limit=1';
        const photonResponse = await fetch(photonUrl);
        const photonData = await photonResponse.json();
        if (photonData.features && photonData.features.length > 0) {
          const [lng, lat] = photonData.features[0].geometry.coordinates;
          if (typeof lat === 'number' && typeof lng === 'number') {
            // Cache the result
            cacheGeocodingResult(query, lat, lng);
            return { lat, lng };
          }
        }
        // Fallback to Nominatim API
        // Note: Nominatim has 1 req/sec rate limit. We add delays to respect this.
        await new Promise(resolve => setTimeout(resolve, 1200));  // Wait 1.2 seconds between requests
        try {
          const nominatimUrl = 'https://nominatim.openstreetmap.org/search?' +
            'q=' + encodeURIComponent(query) +
            '&viewbox=34,29,36,34' +  // Israel viewbox
            '&bounded=1' +              // Only search within viewbox
            '&limit=1&format=json&countrycodes=il' +
            '&accept-language=he';  // Prefer Hebrew results
          const nominatimResponse = await fetch(nominatimUrl, {
            headers: { 'User-Agent': 'Festival-Map-App' }
          });
          const nominatimData = await nominatimResponse.json();
          if (nominatimData && nominatimData.length > 0) {
            const lat = parseFloat(nominatimData[0].lat);
            const lng = parseFloat(nominatimData[0].lon);
            if (typeof lat === 'number' && typeof lng === 'number') {
              // Cache the result
              cacheGeocodingResult(query, lat, lng);
              console.log('âœ“ Nominatim geocoded: ' + query);
              return { lat, lng };
            }
          }
        } catch (nominatimErr) {
          logError(`Nominatim geocode for "${query}"`, nominatimErr);
        }
      } catch (err) {
        logError(`Photon geocode for "${query}"`, err);
      }
      return null;
    }

    // Fetch events from the Hanadiv festival API and display them on the map
    async function loadEvents() {
      console.log('ğŸ“‚ loadEvents() function called');
      try {
        console.log('ğŸŒ Fetching events from API...');
        const response = await fetch('https://api.hanadiv.org/event?festival=2025');
        console.log('ğŸ“¦ API response received:', response.status);

        if (!response.ok) {
          throw new Error(`API returned status ${response.status}`);
        }
        const events = await response.json();
        console.log('âœ“ JSON parsed, received ' + events.length + ' events');

        if (!Array.isArray(events)) {
          throw new Error('API response is not an array');
        }
        // Save the entire events array globally so we can filter by date later
        window.allEvents = events;
        console.log(`âœ… Loaded ${events.length} events from API`);
        // Function to geocode a single event using a hierarchy of search terms. It first attempts to geocode
        // with street and houseNumber. If no coordinates are found, it will fall back to using placeNotes
        // (or placeDescription) combined with Pardes Hana-Karkur and Israel. Results are cached in
        // geocodeCache and persisted in localStorage to improve future lookups.
        const geocodeEvent = async (event) => {
          // Use the shared tryGeocode function defined at module level
          // Progressive query strategy: try increasingly specific queries
          // This matches how Google Maps works - simpler queries often succeed better

          // Attempt 1: Just street and house number (simplest query)
          if (event.street && event.houseNumber) {
            const simpleQuery = event.street + ' ' + event.houseNumber;
            const result = await tryGeocode(simpleQuery);
            if (result) {
              return { event, lat: result.lat, lng: result.lng, addressStr: simpleQuery };
            }
          }

          // Attempt 2: Street and house number with Pardes Hana
          if (event.street && event.houseNumber) {
            const withCityQuery = event.street + ' ' + event.houseNumber + ' Pardes Hana';
            const result = await tryGeocode(withCityQuery);
            if (result) {
              return { event, lat: result.lat, lng: result.lng, addressStr: withCityQuery };
            }
          }

          // Attempt 3: Street and house number with full address (original format)
          if (event.street && event.houseNumber) {
            const fullQuery = event.street + ' ' + event.houseNumber + ' Pardes Hana-Karkur Israel';
            const result = await tryGeocode(fullQuery);
            if (result) {
              return { event, lat: result.lat, lng: result.lng, addressStr: fullQuery };
            }
          }

          // Attempt 4: Try placeDescription or placeNotes without city/country
          if (event.placeDescription || event.placeNotes) {
            const placeQuery = event.placeDescription || event.placeNotes;
            const result = await tryGeocode(placeQuery);
            if (result) {
              return { event, lat: result.lat, lng: result.lng, addressStr: placeQuery };
            }
          }

          // Attempt 5: Try placeDescription or placeNotes with city
          if (event.placeDescription || event.placeNotes) {
            const placeWithCityQuery = (event.placeDescription || event.placeNotes) + ' Pardes Hana';
            const result = await tryGeocode(placeWithCityQuery);
            if (result) {
              return { event, lat: result.lat, lng: result.lng, addressStr: placeWithCityQuery };
            }
          }

          // Attempt 6: Try placeDescription or placeNotes with full address
          if (event.placeDescription || event.placeNotes) {
            const placeFullQuery = (event.placeDescription || event.placeNotes) + ' Pardes Hana-Karkur Israel';
            const result = await tryGeocode(placeFullQuery);
            if (result) {
              return { event, lat: result.lat, lng: result.lng, addressStr: placeFullQuery };
            }
            // Even if geocode fails, record the query for transparency
            return { event, addressStr: placeFullQuery };
          }

          // If no usable address was found, return event without coordinates
          return { event };
        };
        // Fast initial geocoding: uses shared tryGeocode() with multiple strategies
        const fastGeocodeEvent = async (event) => {
          // Fast geocoding: try multiple queries starting with most accurate
          let result = null;

          // Attempt 1: Street + House + English city name (most reliable for OSM data)
          if (event.street && event.houseNumber && !result) {
            const query1 = event.street + ' ' + event.houseNumber + ' Pardes Hana';
            result = await tryGeocode(query1);
          }

          // Attempt 2: Street + House + City + Country (with geographic context)
          if (event.street && event.houseNumber && !result) {
            const query2 = event.street + ' ' + event.houseNumber + ' Pardes Hana, Israel';
            result = await tryGeocode(query2);
          }

          // Attempt 3: Street + House + Hebrew city name (fallback)
          if (event.street && event.houseNumber && !result) {
            const query3 = event.street + ' ' + event.houseNumber + ' ×¤×¨×“×¡ ×—× ×”';
            result = await tryGeocode(query3);
          }

          // If we found coordinates, return them
          if (result && typeof result.lat === 'number' && typeof result.lng === 'number') {
            return { event, lat: result.lat, lng: result.lng };
          }

          // If no usable address was found, return event without coordinates
          return { event };
        };
        // Geocode all events concurrently - fast initial pass only
        const geocodedEvents = await Promise.all(events.map(fastGeocodeEvent));
        // Group events by geocoded location and create markers per location
        let geocodedCount = 0;
        const locationGroups = {};
        geocodedEvents.forEach(({ event, lat, lng }) => {
          if (typeof lat === 'number' && typeof lng === 'number') {
            geocodedCount++;
            const key = lat.toFixed(5) + ',' + lng.toFixed(5);
            if (!locationGroups[key]) {
              locationGroups[key] = { lat, lng, events: [] };
            }
            locationGroups[key].events.push(event);
          }
        });
        // Create markers for each location group
        Object.keys(locationGroups).forEach((key) => {
          const group = locationGroups[key];
          const { lat, lng, events: groupEvents } = group;
          const marker = L.marker([lat, lng]).addTo(map);
          marker.groupKey = key;
          marker.groupEvents = groupEvents;
          marker.currentIndex = 0;
          // Bind popup with content for the first event in this group
          marker.bindPopup(buildPopupContent(groupEvents[0], key, 0));
          // Store marker for this location
          markerLocationMap[key] = marker;
          // Map each event ID in this group to this marker and location
          groupEvents.forEach(ev => {
            markers[ev.eventID] = { marker, lat, lng, groupKey: key };
          });
          // When marker is clicked, update details panel and highlight corresponding list item
          marker.on('click', () => {
            const currentEvent = marker.groupEvents[marker.currentIndex];
            highlightListItem(currentEvent.eventID);
            updateDetails(currentEvent, lat, lng);
          });
        });
        // Update statistics counts in the sidebar
        console.log('ğŸ“Š Updating event counts...');
        const totalEvents = events.length;
        const missingCount = totalEvents - geocodedCount;
        const countsEl = document.getElementById('counts');
        console.log('ğŸ“ countsEl found:', countsEl !== null);

        if (countsEl) {
          countsEl.innerHTML =
            '<strong>×¡×”\"×› ××™×¨×•×¢×™×:</strong> ' + totalEvents +
            '<br><strong>××•×¤×•:</strong> ' + geocodedCount +
            '<br><strong>×œ× × ××¦××•:</strong> ' + missingCount;
          console.log('âœ… Event counts updated');
        } else {
          console.warn('âš ï¸  counts element not found');
        }

        // Build day filter checkboxes
        console.log('ğŸ“… Building day filter checkboxes...');
        const dayFilterContainer = document.getElementById('dayFilterContainer');
        if (!dayFilterContainer) {
          console.warn('âš ï¸  dayFilterContainer not found');
          throw new Error('dayFilterContainer element not found');
        }
        // Clear any existing checkboxes
        dayFilterContainer.innerHTML = '<strong>×¡×™× ×•×Ÿ ×œ×¤×™ ×™××™×:</strong><br />';
        const uniqueDates = Array.from(new Set(window.allEvents.map(ev => ev.date))).sort();
        uniqueDates.forEach((date) => {
          const label = document.createElement('label');
          label.style.display = 'block';
          const checkbox = document.createElement('input');
          checkbox.type = 'checkbox';
          checkbox.value = date;
          checkbox.addEventListener('change', renderEventList);
          label.appendChild(checkbox);
          label.appendChild(document.createTextNode(' ' + date));
          dayFilterContainer.appendChild(label);
        });
        // Add event listener for available filter
        console.log('ğŸ”§ Setting up event listeners...');
        const availableFilter = document.getElementById('availableFilter');
        console.log('ğŸ“ availableFilter found:', availableFilter !== null);

        if (availableFilter) {
          if (!availableFilter._listenerAttached) {
            availableFilter.addEventListener('change', renderEventList);
            availableFilter._listenerAttached = true;
            console.log('âœ… Available filter listener attached');
          }
        } else {
          console.warn('âš ï¸  availableFilter element not found');
        }

        // Render the initial event list
        console.log('ğŸ¨ Rendering initial event list...');
        renderEventList();

        // Add search input event listener
        const searchInput = document.getElementById('searchInput');
        if (searchInput) {
          searchInput.addEventListener('input', renderEventList);
        }
      } catch (err) {
        logError('loadEvents', err);
        // Show error message to user
        const countsEl = document.getElementById('counts');
        if (countsEl) {
          countsEl.innerHTML = '<p style="color: red;">âŒ ×©×’×™××” ×‘×˜×¢×™× ×ª ××™×¨×•×¢×™×. ×‘×“×•×§ ××ª ×—×™×‘×•×¨ ×”××™× ×˜×¨× ×˜.</p>';
        }
      }
    }

    // Background geocoding function to find coordinates for events without them
    async function startBackgroundGeocoding() {
      console.log('ğŸ” startBackgroundGeocoding() started');
      // Immediately show progress bar
      const progressEl = document.getElementById('geocodeProgress');
      const progressBarFill = document.getElementById('progressBarFill');
      const progressText = document.getElementById('progressText');

      console.log('ğŸ“ Progress elements - progressEl:', progressEl !== null, 'progressBarFill:', progressBarFill !== null, 'progressText:', progressText !== null);

      if (!progressEl || !progressBarFill || !progressText) {
        console.warn('âš ï¸  Progress elements not found, skipping visual feedback');
        return;
      }

      progressEl.classList.add('active');
      console.log('âœ“ Progress bar activated');

      // Find events without coordinates
      console.log('ğŸ” Finding events that need geocoding...');
      const eventsNeedingGeocoding = [];
      window.allEvents.forEach(event => {
        if (!markers[event.eventID]) {
          eventsNeedingGeocoding.push(event);
        }
      });

      console.log('ğŸ“ Events needing geocoding:', eventsNeedingGeocoding.length);

      // Update progress text even if no events need geocoding
      if (eventsNeedingGeocoding.length === 0) {
        console.log('âœ… All events already geocoded!');
        progressText.textContent = '×”×›×œ ×œ××¦××•! âœ“';
        await new Promise(resolve => setTimeout(resolve, 1000));
        progressEl.classList.remove('active');
        return;
      }

      // Note: Uses the shared tryGeocode() function defined earlier for consistent results

      // Process events one at a time with improved queries
      for (let i = 0; i < eventsNeedingGeocoding.length; i++) {
        const event = eventsNeedingGeocoding[i];

        // Update progress bar in real-time
        const percentage = Math.round(((i + 1) / eventsNeedingGeocoding.length) * 100);
        progressBarFill.style.width = percentage + '%';
        progressBarFill.textContent = percentage + '%';
        progressText.textContent = (i + 1) + ' / ' + eventsNeedingGeocoding.length + ' ××™×¨×•×¢×™×';

        // Try geocoding with improved strategies (starting with most specific)
        let result = null;

        // Attempt 1: Street + House + Hebrew city name (most accurate for Israel)
        if (event.street && event.houseNumber && !result) {
          const query1 = event.street + ' ' + event.houseNumber + ' ×¤×¨×“×¡ ×—× ×”';
          result = await tryGeocode(query1);
        }

        // Attempt 2: Street + House + English city name
        if (event.street && event.houseNumber && !result) {
          const query2 = event.street + ' ' + event.houseNumber + ' Pardes Hana';
          result = await tryGeocode(query2);
        }

        // Attempt 3: Street + House + City + Country
        if (event.street && event.houseNumber && !result) {
          const query3 = event.street + ' ' + event.houseNumber + ' Pardes Hana, Israel';
          result = await tryGeocode(query3);
        }

        // Attempt 4: Place description with city
        if ((event.placeDescription || event.placeNotes) && !result) {
          const query4 = (event.placeDescription || event.placeNotes) + ' ×¤×¨×“×¡ ×—× ×”';
          result = await tryGeocode(query4);
        }

        // Attempt 5: Place description with English city
        if ((event.placeDescription || event.placeNotes) && !result) {
          const query5 = (event.placeDescription || event.placeNotes) + ' Pardes Hana';
          result = await tryGeocode(query5);
        }

        // Attempt 6: Just place description
        if ((event.placeDescription || event.placeNotes) && !result) {
          const query6 = event.placeDescription || event.placeNotes;
          result = await tryGeocode(query6);
        }

        // If we found coordinates, add the marker to the map immediately
        if (result && typeof result.lat === 'number' && typeof result.lng === 'number') {
          const { lat, lng } = result;
          const key = lat.toFixed(5) + ',' + lng.toFixed(5);

          // Update or create marker at this location
          let marker = markerLocationMap[key];
          if (!marker) {
            // Create new marker and add to map immediately
            marker = L.marker([lat, lng]).addTo(map);
            marker.groupKey = key;
            marker.groupEvents = [];
            marker.currentIndex = 0;
            markerLocationMap[key] = marker;

            // Setup marker click handler
            marker.on('click', () => {
              const currentEvent = marker.groupEvents[marker.currentIndex];
              highlightListItem(currentEvent.eventID);
              updateDetails(currentEvent, lat, lng);
            });
          }

          // Add this event to the marker's group
          if (!marker.groupEvents.includes(event)) {
            marker.groupEvents.push(event);
          }
          markers[event.eventID] = { marker, lat, lng, groupKey: key };

          // Update popup content with the correct event index
          const eventIndex = marker.groupEvents.length - 1;
          marker.bindPopup(buildPopupContent(marker.groupEvents[eventIndex], key, eventIndex));

          // Update counts immediately after finding a location
          let totalGeocoded = 0;
          Object.keys(markers).forEach(eventID => {
            if (markers[eventID]) totalGeocoded++;
          });
          const countsEl = document.getElementById('counts');
          const totalEvents = window.allEvents.length;
          const missingCount = totalEvents - totalGeocoded;
          countsEl.innerHTML =
            '<strong>×¡×”"×› ××™×¨×•×¢×™×:</strong> ' + totalEvents +
            '<br><strong>××•×¤×•:</strong> ' + totalGeocoded +
            '<br><strong>×œ× × ××¦××•:</strong> ' + missingCount;

          // Re-render the event list in real-time to show new event immediately
          renderEventList();
        }

        // Yield control to browser frequently to keep UI responsive
        if (i % 2 === 0) {
          await new Promise(resolve => setTimeout(resolve, 50));
        }
      }

        // Hide progress bar and update final statistics
        if (progressEl) progressEl.classList.remove('active');

        // Update counts with final numbers
        let totalGeocoded = 0;
        Object.keys(markers).forEach(eventID => {
          if (markers[eventID]) totalGeocoded++;
        });
        const countsEl = document.getElementById('counts');
        const totalEvents = window.allEvents.length;
        const missingCount = totalEvents - totalGeocoded;
        if (countsEl) {
          countsEl.innerHTML =
            '<strong>×¡×”"×› ××™×¨×•×¢×™×:</strong> ' + totalEvents +
            '<br><strong>××•×¤×•:</strong> ' + totalGeocoded +
            '<br><strong>×œ× × ××¦××•:</strong> ' + missingCount;
        }

        // Re-render the event list to update styling
        renderEventList();
    }

    // Trigger the data load on page load
    console.log('ğŸš€ App initialization started');

    // Load GitHub corrections in background (non-blocking), then load events
    console.log('ğŸ“¥ Loading GitHub corrections (non-blocking)...');
    loadCorrectionsFromGitHub().catch(err => {
      console.warn('GitHub corrections load failed, continuing with local cache');
    });

    // Load events and start background geocoding
    console.log('ğŸ“¡ Calling loadEvents()...');
    loadEvents().then(() => {
      console.log('âœ… loadEvents() completed successfully');
      console.log('ğŸ” Starting background geocoding...');
      startBackgroundGeocoding();
    }).catch(err => {
      console.error('âŒ loadEvents() failed:', err);
      logError('Failed to load events', err);
    });

    // Setup periodic cache sync (every 30 seconds)
    console.log('â±ï¸  Setting up periodic cache sync (every 30 seconds)...');
    setInterval(() => {
      syncCacheToLocalStorage();
    }, 30000);

    // Setup page unload handler to sync cache before leaving
    window.addEventListener('beforeunload', () => {
      console.log('ğŸ‘‹ Page unloading, syncing cache...');
      syncCacheToLocalStorage();
      syncCacheToGitHub().catch(err => {
        console.warn('GitHub sync failed on page unload (non-blocking):', err);
      });
    });

    /**
     * Render the list of events in the sidebar based on the selected date filter.
     * If no date is selected, all events are shown. Events that could not be
     * geocoded are styled with the `not-found` class and will update the details
     * panel with a message when clicked.
     */
    function renderEventList() {
      console.log('ğŸ¨ renderEventList() called');
      try {
        const eventListEl = document.getElementById('eventList');
        console.log('ğŸ“ eventListEl found:', eventListEl !== null);

        if (!eventListEl) {
          console.error('âŒ eventList element not found! Cannot render events.');
          return;
        }

        // Clear existing list
        eventListEl.innerHTML = '';
        console.log('âœ“ Event list cleared');

        if (!window.allEvents) {
          console.warn('âš ï¸  window.allEvents not available');
          return;
        }
        console.log('ğŸ“Š Processing ' + window.allEvents.length + ' events');
        // Gather selected days from checkboxes
        const dayCheckboxes = document.querySelectorAll('#dayFilterContainer input[type=checkbox]:checked');
        const selectedDays = Array.from(dayCheckboxes).map(cb => cb.value);
        // Determine if only available events should be shown
        const availableFilterEl = document.getElementById('availableFilter');
        console.log('ğŸ“ availableFilter found:', availableFilterEl !== null);
        const showAvailableOnly = availableFilterEl ? availableFilterEl.checked : false;
        console.log('âœ“ Filter settings loaded, showAvailableOnly=' + showAvailableOnly);
        // Helper to determine if an event has available spots
        function isEventAvailable(ev) {
          // Number of seats taken is the count of attendee records (each record represents a reserved seat)
          const registrants = (ev.attendees && Array.isArray(ev.attendees)) ? ev.attendees.length : 0;
          // Determine the actual capacity available for registration. Prefer totalNumberOfPeopleThatCanAttend or limitNumberOfPeople if present,
          // otherwise fall back to maxNumberOfPeople. If none are provided, consider the event as having unlimited capacity (always available).
          const capacities = [];
          if (typeof ev.totalNumberOfPeopleThatCanAttend === 'number') capacities.push(ev.totalNumberOfPeopleThatCanAttend);
          if (typeof ev.limitNumberOfPeople === 'number') capacities.push(ev.limitNumberOfPeople);
          if (typeof ev.maxNumberOfPeople === 'number') capacities.push(ev.maxNumberOfPeople);
          // Filter out negative or zero capacities
          const validCaps = capacities.filter(cap => cap > 0);
          // Use the minimum provided capacity if multiple are available
          const actualCap = validCaps.length > 0 ? Math.min.apply(null, validCaps) : undefined;
          if (typeof actualCap === 'number') {
            return registrants < actualCap;
          }
          // If no capacity information is provided, assume seats are available
          return true;
        }
        // Get search query
        const searchInput = document.getElementById('searchInput');
        const searchQuery = searchInput ? searchInput.value.toLowerCase() : '';

        // Filter events based on selected days, availability, and search
        const eventsToShow = window.allEvents.filter((ev) => {
          const matchesDay = selectedDays.length > 0 ? selectedDays.includes(ev.date) : true;
          const matchesAvailability = showAvailableOnly ? isEventAvailable(ev) : true;
          // Search in title, description, and location
          const matchesSearch = searchQuery === '' ||
                               (ev.title && ev.title.toLowerCase().includes(searchQuery)) ||
                               (ev.placeDescription && ev.placeDescription.toLowerCase().includes(searchQuery)) ||
                               (ev.street && ev.street.toLowerCase().includes(searchQuery));
          return matchesDay && matchesAvailability && matchesSearch;
        });
        // Display each event
        eventsToShow.forEach((ev) => {
          const item = document.createElement('div');
          item.className = 'event-item';
          // Store event ID as data attribute for later reference
          item.dataset.eventId = ev.eventID;
          // Mark events without coordinates as not-found
          if (!markers[ev.eventID]) {
            item.classList.add('not-found');
          }
          // Add time-based highlighting
          if (isHappeningNow(ev)) {
            item.classList.add('happening-now');
          } else if (isHappeningSoon(ev)) {
            item.classList.add('happening-soon');
          }
          // Construct label with title and date
          const title = ev.title || '×œ×œ× ×›×•×ª×¨×ª';
          const dateStr = ev.date || '';
          const favIcon = isFavorited(ev.eventID) ? 'â¤ï¸' : 'ğŸ¤';
          // Create structure with favorite indicator and text
          item.innerHTML = '<span class="favorite-indicator">' + favIcon + '</span> ' + title + (dateStr ? ' (' + dateStr + ')' : '');
          // Store list item for highlighting later
          listItemByEventId[ev.eventID] = item;
          item.addEventListener('click', () => {
            // Highlight in the list
            highlightListItem(ev.eventID);
            // Pan to marker if available
            const record = markers[ev.eventID];
            if (record) {
              map.setView([record.lat, record.lng], 15);
              // Ensure marker popup shows the correct event in group
              const marker = record.marker;
              if (marker) {
                marker.currentIndex = marker.groupEvents.findIndex(e => e.eventID === ev.eventID);
                marker.setPopupContent(buildPopupContent(ev, record.groupKey, marker.currentIndex));
                marker.openPopup();
              }
              updateDetails(ev, record.lat, record.lng);
            } else {
              updateDetails(ev, null, null);
            }
          });
          eventListEl.appendChild(item);
        });
      } catch (err) {
        logError('renderEventList', err);
      }
    }

    /**
     * Build popup HTML content for a specific event in a location group.
     * Includes navigation controls if multiple events share the same location.
     *
     * @param {Object} event The event object to display.
     * @param {string} key The location group key.
     * @param {number} index The index of this event within the group.
     * @returns {string} HTML markup for the popup.
     */
    function buildPopupContent(event, key, index) {
      // Compose optional links
      const link1 = createLink(event.externalLink1);
      const link2 = createLink(event.externalLink2);
      const links = [link1, link2].filter(Boolean).join(' | ');
      // Compose the search address string
      const addrParts = [];
      if (event.street) addrParts.push(event.street);
      if (event.houseNumber) addrParts.push(event.houseNumber);
      addrParts.push('Pardes Hana-Karkur');
      addrParts.push('Israel');
      const geocodeQuery = addrParts.filter(Boolean).join(' ');
      const addressLine = [event.street || '', event.houseNumber || ''].filter(Boolean).join(' ');
      const attendeesCount = (event.attendees && Array.isArray(event.attendees)) ? event.attendees.length : 0;
      // Determine actual capacity using totalNumberOfPeopleThatCanAttend, limitNumberOfPeople or maxNumberOfPeople
      const caps = [];
      if (typeof event.totalNumberOfPeopleThatCanAttend === 'number') caps.push(event.totalNumberOfPeopleThatCanAttend);
      if (typeof event.limitNumberOfPeople === 'number') caps.push(event.limitNumberOfPeople);
      if (typeof event.maxNumberOfPeople === 'number') caps.push(event.maxNumberOfPeople);
      const positiveCaps = caps.filter(cap => cap > 0);
      let actualCap;
      if (positiveCaps.length > 0) {
        actualCap = Math.min.apply(null, positiveCaps);
      }
      let html = '<div class="popup" onclick="event.stopPropagation();">';
      html += '<h3>' + (event.title || '') + '</h3>';
      if (event.date) html += '<p><strong>×ª××¨×™×š:</strong> ' + event.date + '</p>';
      if (event.hour) html += '<p><strong>×©×¢×”:</strong> ' + event.hour + '</p>';
      if (addressLine) html += '<p><strong>×›×ª×•×‘×ª:</strong> ' + addressLine + '</p>';
      if (event.placeDescription) html += '<p><strong>×ª×™××•×¨ ×”××§×•×:</strong> ' + event.placeDescription + '</p>';
      if (typeof actualCap === 'number') {
        html += '<p><strong>×ª×¤×•×¡×”:</strong> ' + attendeesCount + ' / ' + actualCap + '</p>';
      }
      if (event.details) html += '<p>' + event.details.replace(/\n/g, '<br>') + '</p>';
      if (links) html += '<p>' + links + '</p>';
      if (event.eventID) {
        const eventPageUrl = 'https://2025.hanadiv.org/event-page/' + event.eventID;
        html += '<p><a href="' + eventPageUrl + '" target="_blank" rel="noopener">×œ×¢××•×“ ×”××™×¨×•×¢</a></p>';
      }
      html += '<p><strong>×›×ª×•×‘×ª ×œ×—×™×¤×•×©:</strong> ' + geocodeQuery + '</p>';
      // Navigation controls if multiple events at the same location
      const marker = markerLocationMap[key];
      if (marker && marker.groupEvents && marker.groupEvents.length > 1) {
        const total = marker.groupEvents.length;
        const pos = index + 1;
        html += '<div class="nav-controls">' +
          '<button onclick="event.stopPropagation(); navigateMarker(\'' + key + '\', -1); return false;">â—€</button> ' +
          pos + '/' + total + ' ' +
          '<button onclick="event.stopPropagation(); navigateMarker(\'' + key + '\', 1); return false;">â–¶</button>' +
          '</div>';
      }
      html += '</div>';
      return html;
    }

    /**
     * Navigate between events at the same location.
     * Adjusts the marker's current index, updates the popup content and details panel,
     * and highlights the corresponding list item.
     *
     * @param {string} key The location group key.
     * @param {number} direction +1 for next event, -1 for previous event.
     */
    function navigateMarker(key, direction) {
      const marker = markerLocationMap[key];
      if (!marker || !marker.groupEvents) return;
      const total = marker.groupEvents.length;
      if (total <= 1) return;
      let newIndex = marker.currentIndex + direction;
      if (newIndex < 0) newIndex = total - 1;
      if (newIndex >= total) newIndex = 0;
      marker.currentIndex = newIndex;
      const event = marker.groupEvents[newIndex];

      // Check if popup is currently open
      const isPopupOpen = marker.isPopupOpen();

      // Update the popup content
      marker.setPopupContent(buildPopupContent(event, key, newIndex));

      // If popup was open, ensure it stays open after content update
      if (isPopupOpen) {
        marker.openPopup();
      }

      highlightListItem(event.eventID);
      // Update details panel and recenter map
      const latLng = marker.getLatLng();
      updateDetails(event, latLng.lat, latLng.lng);
    }

    /**
     * Highlight the list item corresponding to the given event ID.
     * Removes the 'active' class from all items, adds it to the desired item,
     * and scrolls it into view.
     *
     * @param {number|string} eventId The ID of the event to highlight.
     */
    function highlightListItem(eventId) {
      document.querySelectorAll('.event-item').forEach((el) => el.classList.remove('active'));
      const item = listItemByEventId[eventId];
      if (item) {
        item.classList.add('active');
        // Scroll into view for better UX
        item.scrollIntoView({ behavior: 'smooth', block: 'center' });
      }
    }
  </script>
</body>
</html>
