<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Festival Map - Unit Tests</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      padding: 20px;
      background: #f5f5f5;
    }
    .test-suite {
      background: white;
      padding: 15px;
      margin: 10px 0;
      border-radius: 5px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    .test-case {
      padding: 10px;
      margin: 5px 0;
      border-left: 4px solid #ddd;
    }
    .test-case.pass {
      border-left-color: #4CAF50;
      background: #f1f8f4;
    }
    .test-case.fail {
      border-left-color: #f44336;
      background: #fef5f5;
    }
    .test-case.skip {
      border-left-color: #ff9800;
      background: #fff8f0;
    }
    .summary {
      margin-top: 30px;
      padding: 20px;
      background: white;
      border-radius: 5px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    .summary h2 {
      margin-top: 0;
    }
    code {
      background: #f4f4f4;
      padding: 2px 6px;
      border-radius: 3px;
      font-family: 'Courier New', monospace;
    }
  </style>
</head>
<body>
  <h1>Festival Map - Unit Tests</h1>
  <div id="test-output"></div>
  <div class="summary">
    <h2>Test Results</h2>
    <p>Total: <span id="total">0</span></p>
    <p>Passed: <span id="passed" style="color: #4CAF50;">0</span></p>
    <p>Failed: <span id="failed" style="color: #f44336;">0</span></p>
    <p>Skipped: <span id="skipped" style="color: #ff9800;">0</span></p>
  </div>

  <script>
    // Simple test framework
    class TestRunner {
      constructor() {
        this.tests = [];
        this.results = { pass: 0, fail: 0, skip: 0 };
      }

      describe(suiteName, fn) {
        const suite = document.createElement('div');
        suite.className = 'test-suite';
        suite.innerHTML = `<h3>${suiteName}</h3>`;
        document.getElementById('test-output').appendChild(suite);
        this.currentSuite = suite;
        fn();
      }

      it(testName, fn, skip = false) {
        const testCase = document.createElement('div');
        testCase.className = 'test-case';

        if (skip) {
          testCase.classList.add('skip');
          testCase.textContent = `⊙ ${testName} (SKIPPED)`;
          this.results.skip++;
        } else {
          try {
            fn();
            testCase.classList.add('pass');
            testCase.textContent = `✓ ${testName}`;
            this.results.pass++;
          } catch (err) {
            testCase.classList.add('fail');
            testCase.innerHTML = `✗ ${testName}<br><small>${err.message}</small>`;
            this.results.fail++;
          }
        }
        this.currentSuite.appendChild(testCase);
      }

      expect(value) {
        return {
          toBe: (expected) => {
            if (value !== expected) {
              throw new Error(`Expected ${value} to be ${expected}`);
            }
          },
          toEqual: (expected) => {
            if (JSON.stringify(value) !== JSON.stringify(expected)) {
              throw new Error(`Expected ${JSON.stringify(value)} to equal ${JSON.stringify(expected)}`);
            }
          },
          toBeTrue: () => {
            if (value !== true) throw new Error(`Expected ${value} to be true`);
          },
          toBeFalse: () => {
            if (value !== false) throw new Error(`Expected ${value} to be false`);
          },
          toBeNull: () => {
            if (value !== null) throw new Error(`Expected ${value} to be null`);
          },
          toBeDefined: () => {
            if (value === undefined) throw new Error(`Expected value to be defined`);
          },
          toBeArray: () => {
            if (!Array.isArray(value)) throw new Error(`Expected ${value} to be an array`);
          },
          toBeObject: () => {
            if (typeof value !== 'object' || value === null) {
              throw new Error(`Expected ${value} to be an object`);
            }
          },
          toContain: (item) => {
            if (!value.includes(item)) {
              throw new Error(`Expected ${value} to contain ${item}`);
            }
          },
          toHaveLength: (length) => {
            if (value.length !== length) {
              throw new Error(`Expected length ${value.length} to be ${length}`);
            }
          }
        };
      }

      printSummary() {
        const total = this.results.pass + this.results.fail + this.results.skip;
        document.getElementById('total').textContent = total;
        document.getElementById('passed').textContent = this.results.pass;
        document.getElementById('failed').textContent = this.results.fail;
        document.getElementById('skipped').textContent = this.results.skip;

        const summary = document.querySelector('.summary');
        if (this.results.fail === 0) {
          summary.style.borderTop = '4px solid #4CAF50';
        } else {
          summary.style.borderTop = '4px solid #f44336';
        }
      }
    }

    const runner = new TestRunner();

    // ===== Test Suites =====

    // Test 1: Validate geocodeCache initialization
    runner.describe('Geocode Cache', () => {
      runner.it('should initialize as empty object when localStorage is empty', () => {
        localStorage.removeItem('geocodeCache');
        const cache = (() => {
          try {
            const stored = localStorage.getItem('geocodeCache');
            return stored ? JSON.parse(stored) : {};
          } catch (e) {
            return {};
          }
        })();
        runner.expect(cache).toEqual({});
      });

      runner.it('should parse existing cache from localStorage', () => {
        const testCache = { 'test query': { lat: 32.5, lng: 34.9, timestamp: '2025-11-06T12:00:00Z' } };
        localStorage.setItem('geocodeCache', JSON.stringify(testCache));
        const cache = (() => {
          try {
            const stored = localStorage.getItem('geocodeCache');
            return stored ? JSON.parse(stored) : {};
          } catch (e) {
            return {};
          }
        })();
        runner.expect(cache).toEqual(testCache);
      });
    });

    // Test 2: Validate coordinateOverrides initialization
    runner.describe('Coordinate Overrides', () => {
      runner.it('should initialize as empty object when localStorage is empty', () => {
        localStorage.removeItem('coordinateOverrides');
        const overrides = (() => {
          try {
            const stored = localStorage.getItem('coordinateOverrides');
            return stored ? JSON.parse(stored) : {};
          } catch (e) {
            return {};
          }
        })();
        runner.expect(overrides).toEqual({});
      });

      runner.it('should handle corrupted localStorage data gracefully', () => {
        localStorage.setItem('coordinateOverrides', 'invalid json {{{');
        const overrides = (() => {
          try {
            const stored = localStorage.getItem('coordinateOverrides');
            return stored ? JSON.parse(stored) : {};
          } catch (e) {
            return {};
          }
        })();
        runner.expect(overrides).toEqual({});
      });
    });

    // Test 3: Validate function definitions
    runner.describe('Function Definitions', () => {
      runner.it('logError should be defined', () => {
        const logError = function(context, error) {
          const timestamp = new Date().toISOString();
          const errorMsg = error instanceof Error ? error.message : String(error);
          console.error(`[${timestamp}] ${context}:`, errorMsg, error);
        };
        runner.expect(typeof logError).toBe('function');
      });

      runner.it('cacheGeocodingResult should validate input parameters', () => {
        const geocodeCache = {};
        const cacheGeocodingResult = function(query, lat, lng) {
          if (!query || typeof lat !== 'number' || typeof lng !== 'number') {
            return false;
          }
          geocodeCache[query] = { lat, lng, timestamp: new Date().toISOString() };
          return true;
        };

        // Valid input
        runner.expect(cacheGeocodingResult('test', 32.5, 34.9)).toBeTrue();

        // Invalid inputs
        runner.expect(cacheGeocodingResult('', 32.5, 34.9)).toBeFalse();
        runner.expect(cacheGeocodingResult('test', 'not a number', 34.9)).toBeFalse();
        runner.expect(cacheGeocodingResult('test', 32.5, 'not a number')).toBeFalse();
      });
    });

    // Test 4: Validate data structures
    runner.describe('Data Structures', () => {
      runner.it('corrections.json should have required structure', () => {
        const corrections = {
          "overrides": {},
          "geocodeCache": {},
          "lastUpdated": "2025-11-06T12:00:00Z",
          "version": "1.0"
        };
        runner.expect(corrections).toBeObject();
        runner.expect(corrections.overrides).toBeObject();
        runner.expect(corrections.geocodeCache).toBeObject();
      });

      runner.it('geocode cache entry should include required fields', () => {
        const entry = {
          lat: 32.475,
          lng: 34.975,
          timestamp: '2025-11-06T12:00:00Z'
        };
        runner.expect(typeof entry.lat).toBe('number');
        runner.expect(typeof entry.lng).toBe('number');
        runner.expect(typeof entry.timestamp).toBe('string');
      });
    });

    // Test 5: Validate URL handling
    runner.describe('GitHub API Integration', () => {
      runner.it('GitHub corrections URL should be properly formatted', () => {
        const url = 'https://raw.githubusercontent.com/dvirarad/hnadiv-festival-7/main/web-app/corrections.json';
        runner.expect(url).toContain('raw.githubusercontent.com');
        runner.expect(url).toContain('dvirarad/hnadiv-festival-7');
        runner.expect(url).toContain('main');
        runner.expect(url).toContain('corrections.json');
      });

      runner.it('fetch timeout should be set to 5 seconds', () => {
        const timeoutMs = 5000;
        runner.expect(timeoutMs).toBe(5000);
      });
    });

    // Test 6: Validate error handling
    runner.describe('Error Handling', () => {
      runner.it('should not throw on invalid JSON parse', () => {
        try {
          const result = (() => {
            try {
              const stored = 'invalid json';
              return stored ? JSON.parse(stored) : {};
            } catch (e) {
              return {};
            }
          })();
          runner.expect(result).toEqual({});
        } catch (err) {
          throw new Error('Should not throw on invalid JSON');
        }
      });

      runner.it('should gracefully handle missing localStorage', () => {
        // Simulate missing localStorage
        const mockStorage = {
          getItem: () => null,
          setItem: () => { throw new Error('Storage quota exceeded'); }
        };

        const cache = (() => {
          try {
            const stored = mockStorage.getItem('geocodeCache');
            return stored ? JSON.parse(stored) : {};
          } catch (e) {
            return {};
          }
        })();

        runner.expect(cache).toEqual({});
      });
    });

    // Test 7: Validate HTML elements
    runner.describe('DOM Elements (Run in main app)', () => {
      runner.it('Map container should exist (requires index.html)', () => {
        // This test is skipped as it requires the main HTML
      }, true);

      runner.it('EventList element should exist (requires index.html)', () => {
        // This test is skipped as it requires the main HTML
      }, true);

      runner.it('Details panel should exist (requires index.html)', () => {
        // This test is skipped as it requires the main HTML
      }, true);
    });

    // Print results
    runner.printSummary();
  </script>
</body>
</html>
